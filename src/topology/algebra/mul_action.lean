/-
Copyright (c) 2021 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import topology.algebra.monoid
import group_theory.group_action.prod
import group_theory.group_action.basic
import topology.homeomorph
import topology.algebra.const_mul_action

/-!
# Continuous monoid action

In this file we define class `has_continuous_smul`. We say `has_continuous_smul M X` if `M` acts on
`X` and the map `(c, x) ‚Ü¶ c ‚Ä¢ x` is continuous on `M √ó X`. We reuse this class for topological
(semi)modules, vector spaces and algebras.

## Main definitions

* `has_continuous_smul M X` : typeclass saying that the map `(c, x) ‚Ü¶ c ‚Ä¢ x` is continuous
  on `M √ó X`;
* `homeomorph.smul_of_ne_zero`: if a group with zero `G‚ÇÄ` (e.g., a field) acts on `X` and `c : G‚ÇÄ`
  is a nonzero element of `G‚ÇÄ`, then scalar multiplication by `c` is a homeomorphism of `X`;
* `homeomorph.smul`: scalar multiplication by an element of a group `G` acting on `X`
  is a homeomorphism of `X`.
* `units.has_continuous_smul`: scalar multiplication by `MÀ£` is continuous when scalar
  multiplication by `M` is continuous. This allows `homeomorph.smul` to be used with on monoids
  with `G = MÀ£`.

## Main results

Besides homeomorphisms mentioned above, in this file we provide lemmas like `continuous.smul`
or `filter.tendsto.smul` that provide dot-syntax access to `continuous_smul`.
-/

open_locale topological_space pointwise
open filter

/-- Class `has_continuous_smul M X` says that the scalar multiplication `(‚Ä¢) : M ‚Üí X ‚Üí X`
is continuous in both arguments. We use the same class for all kinds of multiplicative actions,
including (semi)modules and algebras. -/
class has_continuous_smul (M X : Type*) [has_scalar M X]
  [topological_space M] [topological_space X] : Prop :=
(continuous_smul : continuous (Œªp : M √ó X, p.1 ‚Ä¢ p.2))

export has_continuous_smul (continuous_smul)

/-- Class `has_continuous_vadd M X` says that the additive action `(+·µ•) : M ‚Üí X ‚Üí X`
is continuous in both arguments. We use the same class for all kinds of additive actions,
including (semi)modules and algebras. -/
class has_continuous_vadd (M X : Type*) [has_vadd M X]
  [topological_space M] [topological_space X] : Prop :=
(continuous_vadd : continuous (Œªp : M √ó X, p.1 +·µ• p.2))

export has_continuous_vadd (continuous_vadd)

attribute [to_additive] has_continuous_smul

section main

variables {M X Y Œ± : Type*} [topological_space M] [topological_space X] [topological_space Y]

section has_scalar

variables [has_scalar M X] [has_continuous_smul M X]

@[priority 100, to_additive] instance has_continuous_smul.has_continuous_const_smul :
  has_continuous_const_smul M X :=
{ continuous_const_smul := Œª _, continuous_smul.comp (continuous_const.prod_mk continuous_id) }

@[to_additive]
lemma filter.tendsto.smul {f : Œ± ‚Üí M} {g : Œ± ‚Üí X} {l : filter Œ±} {c : M} {a : X}
  (hf : tendsto f l (ùìù c)) (hg : tendsto g l (ùìù a)) :
  tendsto (Œª x, f x ‚Ä¢ g x) l (ùìù $ c ‚Ä¢ a) :=
(continuous_smul.tendsto _).comp (hf.prod_mk_nhds hg)

@[to_additive]
lemma filter.tendsto.const_smul {f : Œ± ‚Üí X} {l : filter Œ±} {a : X} (hf : tendsto f l (ùìù a))
  (c : M) :
  tendsto (Œª x, c ‚Ä¢ f x) l (ùìù (c ‚Ä¢ a)) :=
tendsto_const_nhds.smul hf

@[to_additive]
lemma filter.tendsto.smul_const {f : Œ± ‚Üí M} {l : filter Œ±} {c : M}
  (hf : tendsto f l (ùìù c)) (a : X) :
  tendsto (Œª x, (f x) ‚Ä¢ a) l (ùìù (c ‚Ä¢ a)) :=
hf.smul tendsto_const_nhds

variables {f : Y ‚Üí M} {g : Y ‚Üí X} {b : Y} {s : set Y}

@[to_additive]
lemma continuous_within_at.smul (hf : continuous_within_at f s b)
  (hg : continuous_within_at g s b) :
  continuous_within_at (Œª x, f x ‚Ä¢ g x) s b :=
hf.smul hg

@[to_additive]
lemma continuous_within_at.const_smul (hg : continuous_within_at g s b) (c : M) :
  continuous_within_at (Œª x, c ‚Ä¢ g x) s b :=
hg.const_smul c

@[to_additive]
lemma continuous_at.smul (hf : continuous_at f b) (hg : continuous_at g b) :
  continuous_at (Œª x, f x ‚Ä¢ g x) b :=
hf.smul hg

@[to_additive]
lemma continuous_at.const_smul (hg : continuous_at g b) (c : M) :
  continuous_at (Œª x, c ‚Ä¢ g x) b :=
hg.const_smul c

@[to_additive]
lemma continuous_on.smul (hf : continuous_on f s) (hg : continuous_on g s) :
  continuous_on (Œª x, f x ‚Ä¢ g x) s :=
Œª x hx, (hf x hx).smul (hg x hx)

@[to_additive]
lemma continuous_on.const_smul (hg : continuous_on g s) (c : M) :
  continuous_on (Œª x, c ‚Ä¢ g x) s :=
Œª x hx, (hg x hx).const_smul c

@[continuity, to_additive]
lemma continuous.smul (hf : continuous f) (hg : continuous g) :
  continuous (Œª x, f x ‚Ä¢ g x) :=
continuous_smul.comp (hf.prod_mk hg)

@[to_additive]
lemma continuous.const_smul (hg : continuous g) (c : M) :
  continuous (Œª x, c ‚Ä¢ g x) :=
continuous_smul.comp (continuous_const.prod_mk hg)

/-- If a scalar is central, then its right action is continuous when its left action is. -/
instance has_continuous_smul.op [has_scalar M·µê·µí·µñ X] [is_central_scalar M X] :
  has_continuous_smul M·µê·µí·µñ X :=
‚ü® suffices continuous (Œª p : M √ó X, mul_opposite.op p.fst ‚Ä¢ p.snd),
  from this.comp (mul_opposite.continuous_unop.prod_map continuous_id),
  by simpa only [op_smul_eq_smul] using (continuous_smul : continuous (Œª p : M √ó X, _)) ‚ü©

end has_scalar

section monoid

variables [monoid M] [mul_action M X] [has_continuous_smul M X]

@[to_additive] instance units.has_continuous_smul : has_continuous_smul MÀ£ X :=
{ continuous_smul :=
    show continuous ((Œª p : M √ó X, p.fst ‚Ä¢ p.snd) ‚àò (Œª p : MÀ£ √ó X, (p.1, p.2))),
    from continuous_smul.comp ((units.continuous_coe.comp continuous_fst).prod_mk continuous_snd) }

@[to_additive]
lemma smul_closure_subset (c : M) (s : set X) : c ‚Ä¢ closure s ‚äÜ closure (c ‚Ä¢ s) :=
((set.maps_to_image _ _).closure $ continuous_id.const_smul c).image_subset

@[to_additive]
lemma smul_closure_orbit_subset (c : M) (x : X) :
  c ‚Ä¢ closure (mul_action.orbit M x) ‚äÜ closure (mul_action.orbit M x) :=
(smul_closure_subset c _).trans $ closure_mono $ mul_action.smul_orbit_subset _ _

end monoid

section group

variables {G : Type*} [topological_space G] [group G] [mul_action G X]
  [has_continuous_smul G X]

@[to_additive]
lemma tendsto_const_smul_iff {f : Œ± ‚Üí X} {l : filter Œ±} {a : X} (c : G) :
  tendsto (Œª x, c ‚Ä¢ f x) l (ùìù $ c ‚Ä¢ a) ‚Üî tendsto f l (ùìù a) :=
‚ü®Œª h, by simpa only [inv_smul_smul] using h.const_smul c‚Åª¬π,
  Œª h, h.const_smul _‚ü©

variables {f : Y ‚Üí X} {b : Y} {s : set Y}

@[to_additive]
lemma continuous_within_at_const_smul_iff (c : G) :
  continuous_within_at (Œª x, c ‚Ä¢ f x) s b ‚Üî continuous_within_at f s b :=
tendsto_const_smul_iff c

@[to_additive]
lemma continuous_on_const_smul_iff (c : G) : continuous_on (Œª x, c ‚Ä¢ f x) s ‚Üî continuous_on f s :=
forall‚ÇÇ_congr $ Œª b hb, continuous_within_at_const_smul_iff c

@[to_additive]
lemma continuous_at_const_smul_iff (c : G) :
  continuous_at (Œª x, c ‚Ä¢ f x) b ‚Üî continuous_at f b :=
tendsto_const_smul_iff c

@[to_additive]
lemma continuous_const_smul_iff (c : G) :
  continuous (Œª x, c ‚Ä¢ f x) ‚Üî continuous f :=
by simp only [continuous_iff_continuous_at, continuous_at_const_smul_iff]

@[to_additive]
lemma is_open_map_smul (c : G) : is_open_map (Œª x : X, c ‚Ä¢ x) :=
(homeomorph.smul c).is_open_map

@[to_additive] lemma is_open.smul {s : set X} (hs : is_open s) (c : G) : is_open (c ‚Ä¢ s) :=
is_open_map_smul c s hs

@[to_additive]
lemma is_closed_map_smul (c : G) : is_closed_map (Œª x : X, c ‚Ä¢ x) :=
(homeomorph.smul c).is_closed_map

@[to_additive] lemma is_closed.smul {s : set X} (hs : is_closed s) (c : G) : is_closed (c ‚Ä¢ s) :=
is_closed_map_smul c s hs

end group

section group_with_zero

variables {G‚ÇÄ : Type*} [topological_space G‚ÇÄ] [group_with_zero G‚ÇÄ] [mul_action G‚ÇÄ X]
  [has_continuous_smul G‚ÇÄ X]

lemma tendsto_const_smul_iff‚ÇÄ {f : Œ± ‚Üí X} {l : filter Œ±} {a : X} {c : G‚ÇÄ} (hc : c ‚â† 0) :
  tendsto (Œª x, c ‚Ä¢ f x) l (ùìù $ c ‚Ä¢ a) ‚Üî tendsto f l (ùìù a) :=
tendsto_const_smul_iff (units.mk0 c hc)

variables {f : Y ‚Üí X} {b : Y} {c : G‚ÇÄ} {s : set Y}

lemma continuous_within_at_const_smul_iff‚ÇÄ (hc : c ‚â† 0) :
  continuous_within_at (Œª x, c ‚Ä¢ f x) s b ‚Üî continuous_within_at f s b :=
tendsto_const_smul_iff (units.mk0 c hc)

lemma continuous_on_const_smul_iff‚ÇÄ (hc : c ‚â† 0) :
  continuous_on (Œª x, c ‚Ä¢ f x) s ‚Üî continuous_on f s :=
continuous_on_const_smul_iff (units.mk0 c hc)

lemma continuous_at_const_smul_iff‚ÇÄ (hc : c ‚â† 0) :
  continuous_at (Œª x, c ‚Ä¢ f x) b ‚Üî continuous_at f b :=
continuous_at_const_smul_iff (units.mk0 c hc)

lemma continuous_const_smul_iff‚ÇÄ (hc : c ‚â† 0) :
  continuous (Œª x, c ‚Ä¢ f x) ‚Üî continuous f :=
continuous_const_smul_iff (units.mk0 c hc)

/-- Scalar multiplication by a non-zero element of a group with zero acting on `X` is a
homeomorphism from `X` onto itself. -/
protected def homeomorph.smul_of_ne_zero (c : G‚ÇÄ) (hc : c ‚â† 0) : X ‚âÉ‚Çú X :=
homeomorph.smul (units.mk0 c hc)

lemma is_open_map_smul‚ÇÄ {c : G‚ÇÄ} (hc : c ‚â† 0) : is_open_map (Œª x : X, c ‚Ä¢ x) :=
(homeomorph.smul_of_ne_zero c hc).is_open_map

lemma is_open.smul‚ÇÄ {c : G‚ÇÄ} {s : set X} (hs : is_open s) (hc : c ‚â† 0) : is_open (c ‚Ä¢ s) :=
is_open_map_smul‚ÇÄ hc s hs

lemma interior_smul‚ÇÄ {c : G‚ÇÄ} (hc : c ‚â† 0) (s : set X) : interior (c ‚Ä¢ s) = c ‚Ä¢ interior s :=
((homeomorph.smul_of_ne_zero c hc).image_interior s).symm

/-- `smul` is a closed map in the second argument.

The lemma that `smul` is a closed map in the first argument (for a normed space over a complete
normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`. -/
lemma is_closed_map_smul_of_ne_zero {c : G‚ÇÄ} (hc : c ‚â† 0) : is_closed_map (Œª x : X, c ‚Ä¢ x) :=
(homeomorph.smul_of_ne_zero c hc).is_closed_map

/-- `smul` is a closed map in the second argument.

The lemma that `smul` is a closed map in the first argument (for a normed space over a complete
normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`. -/
lemma is_closed_map_smul‚ÇÄ {ùïú M : Type*} [division_ring ùïú] [add_comm_monoid M] [topological_space M]
  [t1_space M] [module ùïú M] [topological_space ùïú] [has_continuous_smul ùïú M] (c : ùïú) :
  is_closed_map (Œª x : M, c ‚Ä¢ x) :=
begin
  rcases eq_or_ne c 0 with (rfl|hne),
  { simp only [zero_smul], exact is_closed_map_const },
  { exact (homeomorph.smul_of_ne_zero c hne).is_closed_map },
end

end group_with_zero

namespace is_unit

variables [monoid M] [mul_action M X] [has_continuous_smul M X]

lemma tendsto_const_smul_iff {f : Œ± ‚Üí X} {l : filter Œ±} {a : X} {c : M} (hc : is_unit c) :
  tendsto (Œª x, c ‚Ä¢ f x) l (ùìù $ c ‚Ä¢ a) ‚Üî tendsto f l (ùìù a) :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ tendsto_const_smul_iff u

variables {f : Y ‚Üí X} {b : Y} {c : M} {s : set Y}

lemma continuous_within_at_const_smul_iff (hc : is_unit c) :
  continuous_within_at (Œª x, c ‚Ä¢ f x) s b ‚Üî continuous_within_at f s b :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ continuous_within_at_const_smul_iff u

lemma continuous_on_const_smul_iff (hc : is_unit c) :
  continuous_on (Œª x, c ‚Ä¢ f x) s ‚Üî continuous_on f s :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ continuous_on_const_smul_iff u

lemma continuous_at_const_smul_iff (hc : is_unit c) :
  continuous_at (Œª x, c ‚Ä¢ f x) b ‚Üî continuous_at f b :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ continuous_at_const_smul_iff u

lemma continuous_const_smul_iff (hc : is_unit c) :
  continuous (Œª x, c ‚Ä¢ f x) ‚Üî continuous f :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ continuous_const_smul_iff u

lemma is_open_map_smul (hc : is_unit c) : is_open_map (Œª x : X, c ‚Ä¢ x) :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ is_open_map_smul u

lemma is_closed_map_smul (hc : is_unit c) : is_closed_map (Œª x : X, c ‚Ä¢ x) :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ is_closed_map_smul u

end is_unit

@[to_additive]
instance has_continuous_mul.has_continuous_smul {M : Type*} [monoid M]
  [topological_space M] [has_continuous_mul M] :
  has_continuous_smul M M :=
‚ü®continuous_mul‚ü©

@[to_additive]
instance [has_scalar M X] [has_scalar M Y] [has_continuous_smul M X]
  [has_continuous_smul M Y] :
  has_continuous_smul M (X √ó Y) :=
‚ü®(continuous_fst.smul (continuous_fst.comp continuous_snd)).prod_mk
  (continuous_fst.smul (continuous_snd.comp continuous_snd))‚ü©

@[to_additive]
instance {Œπ : Type*} {Œ≥ : Œπ ‚Üí Type*}
  [‚àÄ i, topological_space (Œ≥ i)] [Œ† i, has_scalar M (Œ≥ i)] [‚àÄ i, has_continuous_smul M (Œ≥ i)] :
  has_continuous_smul M (Œ† i, Œ≥ i) :=
‚ü®continuous_pi $ Œª i,
  (continuous_fst.smul continuous_snd).comp $
    continuous_fst.prod_mk ((continuous_apply i).comp continuous_snd)‚ü©

end main

section lattice_ops

variables {Œπ : Sort*} {M X : Type*} [topological_space M] [has_scalar M X]

@[to_additive] lemma has_continuous_smul_Inf {ts : set (topological_space X)}
  (h : Œ† t ‚àà ts, @has_continuous_smul M X _ _ t) :
  @has_continuous_smul M X _ _ (Inf ts) :=
{ continuous_smul :=
  begin
    rw ‚Üê @Inf_singleton _ _ ‚Äπtopological_space M‚Ä∫,
    exact continuous_Inf_rng (Œª t ht, continuous_Inf_dom‚ÇÇ (eq.refl _) ht
      (@has_continuous_smul.continuous_smul _ _ _ _ t (h t ht)))
  end }

@[to_additive] lemma has_continuous_smul_infi {ts' : Œπ ‚Üí topological_space X}
  (h : Œ† i, @has_continuous_smul M X _ _ (ts' i)) :
  @has_continuous_smul M X _ _ (‚®Ö i, ts' i) :=
has_continuous_smul_Inf $ set.forall_range_iff.mpr h

@[to_additive] lemma has_continuous_smul_inf {t‚ÇÅ t‚ÇÇ : topological_space X}
  [@has_continuous_smul M X _ _ t‚ÇÅ] [@has_continuous_smul M X _ _ t‚ÇÇ] :
  @has_continuous_smul M X _ _ (t‚ÇÅ ‚äì t‚ÇÇ) :=
by { rw inf_eq_infi, refine has_continuous_smul_infi (Œª b, _), cases b; assumption }

end lattice_ops
